<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--
(C) Copyright 2002-4 Robert Ramey - http://www.rrsd.com . 
Use, modification and distribution is subject to the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../../../boost.css">
<link rel="stylesheet" type="text/css" href="style.css">
<title>Serialization - extended_type_info</title>
</head>
<body link="#0000ff" vlink="#800080">
<table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
  <tr> 
    <td valign="top" width="300"> 
      <h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../boost.png" border="0"></a></h3>
    </td>
    <td valign="top"> 
      <h1 align="center">Serialization</h1>
      <h2 align="center"><code style="white-space: normal">extended_type_info</code></h2>
    </td>
  </tr>
</table>
<hr>
<dl class="page-index">
  <dt><a href="#motivation">Motivation</a>
  <dt><a href="#runtime">Runtime Interface</a>
  <dt><a href="#requirements">Requirements</a>
  <dt><a href="#models">Models</a>
  <dt><a href="#example">Example</a>
</dl>

<h3><a name="motivation">Motivation</a></h3>
The serialization library needs a system like 
<code style="white-space: normal">type_info/typeid()</code> to perform
the following functions
<ol>
  <li>
     given a pointer to a type T discover the true type pointed to.
  <li>
     given an "external" key - determine what type of object to create.
</ol>
<h3>The problem with <code style="white-space: normal">std::type_info</code></h3>
<ul>
  <li>
    The main function we require - <code style="white-space: normal">std::typeid()</code>
    is not available in all environments. Support for this function depends upon
    runtime typing(RTTI) support from the compiler.  This may be non-existent
    or not enabled for reasons such as a percieved inefficiency.
  <li>
    <code style="white-space: normal">std::type_info</code> includes a string
    containing type name.  This would seem to satisfy 2) above.
    But the format of this string is not consistent accross compilers, libraries, 
    and operating systems. This makes it unusable for support of portable archives.
  <li>
    Even if the type name string could somehow be made portable, there is no 
    guarentee that class headers would be included in the same name space accross 
    different applications. In fact, including different headers in different
    name spaces is an accepted method used to avoid name space conflicts.
    Thus the namespace::class_name can't be used as a key.
  <li>
    We may want the ability to serialize objects through a base class even though
    they have no <code style="white-space: normal">virtual</code> function.  That
    is, objects of classes which are not polymorphic in the strict C++ sense.  This
    is not supported by the standard system.
  <li>
    There exists the possibility that different classes use different type id 
    mechanism.  The class header might include this information. If we want to 
    import class headers accross applications, its convenient that the type id
    mechanism support inter-operability accross different type id systems.
</ul>
<h3>Features</h3>
<code style="white-space: normal"><a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">
extended_type_info</a></code> is an implementation
of <code style="white-space: normal">std::type_info</code> functionality with the 
following features:
<ul>
  <li>
    Builds a set of <a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">
    <code style="white-space: normal">extended_type_info</a></code> records - one for each type known
    to the program.
  <li>
    permits association of an arbitrary string key with a type.  Often this key would
    be the class name - but it doesn't have to be.  This key is referred to as
    a GUID - Globally Unique IDentifier.  Presumably it should be unique in the universe.
    Typically this GUID would be in header files and be used to match type accross
    applications.  The macro BOOST_CLASS_EXPORT can be invoked to associate a string
    key with any known type.  We'll refer to these types as "exported types"
  <li>
    permits the "mixing" of type info systems.  For example, one class might use 
    <code style="white-space: normal">typeid()</code> to find the external identifier 
    of a class while another might not.
</ul>

Exported types are maintained in a global table so that given a string key, the
corresponding type can be found.  This facility is used by the serialization library
in order to construct types serialized through a base class pointer.

<h3><a name="runtime">Runtime Interface</a></h3>
<pre><code">
namespace boost { 
namespace serialization {

class BOOST_SERIALIZATION_DECL extended_type_info : 
    private boost::noncopyable 
{
protected:
    // this class can't be used as is. It's just the 
    // common functionality for all type_info replacement
    // systems.  Hence, make these protected
    extended_type_info();
    ~extended_type_info();
    const char * m_key;
    extended_type_info(const char * type_info_key);
public:
    void key_register(const char *key);
    const char * get_key() const;
    static const extended_type_info * find(const char *key);
};

bool operator<(const extended_type_info &rhs) const;
bool operator==(const extended_type_info &rhs) const;

} // namespace serialization 
} // namespace boost
</code></pre>

There must be one and only one <code style="white-space: normal"><a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code>
instance created for each type. For this reason, this class is marked is derived from
<code style="white-space: normal">boost::noncopyable</code>. 

<dl>

<dt><h4><pre><code>
extended_type_info(const char * type_info_key);</code></pre></h4></dt>
<dd>
This constructor should be called by all derived classes.
</dd>

<dt><h4><pre><code>
void key_register(const char *key);
</code></pre></h4></dt>
<dd>
Assign a unique character string identifier to this
<code style="white-space: normal"><a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code>
instance and add it to the corresponding global trable. 
This key is used to identify a type accross different instances of the program.  
In this way, one instance may know what type to create when necessary.  
For this purpose, it must be the same in all program instances which
refer to the same type.
<p>
It may sometimes be referred to as a GUID - a <b>G</b>lobal <b>U</b>nique <b>ID</b>entifier.
<dt><h4><pre><code>
const char *get_key() const;
</code></pre></h4></dt>
<dd>
Retrieves the key for <code style="white-space: normal"><a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code>
instance.  If no key has been associated with the instance, then a NULL is returned.
</dd>

<dt><h4><pre><code>
// in order
bool operator==(
    const extended_type_info & lhs, 
    const extended_type_info & rhs
);
bool operator<(
    const extended_type_info & lhs, 
    const extended_type_info & rhs
);

} // namespace serialization 
} // namespace boost
</code></pre></h4></dt>
<dd>
These non-member functions are used to compare two 
<a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">
<code style="white-space: normal">
extended_type_info
</code> 
</a>
objects. They a strict total ordering on all instances of this class and
are used to implement the following.

<dt><h4><pre><code>
static const extended_type_info * find(const char *key);
</code></pre></h4></dt>
<dd>
Given a character string key or <strong>GUID</strong>, return the address of the 
unique corresponding <code style="white-space: normal"><a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code>
object. 

</dl>

<h3><a name="requirements">Requirements</a></h3>
In order to be used by the serialization library, an implementation of
<code style="white-space: normal">extended_type_info</code>, 
(referred to as ETI here), must be derived from 
<a target="extended_type_info.hpp" href = "../../../boost/serialization/extended_type_info.hpp">
<code style="white-space: normal">
extended_type_info
</code> 
</a>
and also implement the following:

<dl>

<dt><h4><code style="white-space: normal"><pre>
template&lt;class ETI&gt;
static const extended_type_info *
ETI::get_derived_extended_type_info(const T & t);
</pre></code></h4></dt>
<dd>
Return a pointer to the 
<code style="white-space: normal">extended_type_info</code>
instance that corresponds to
the "true type" of the type T.  The "true type" is the lowest type in the
hierarchy of classes.  The type T can always be cast to the "true type" with
a static cast.  Implemention of this function will vary among type id systems
and sometimes will make presumptions about the type T than can be identified
with a particular <code style="white-space: normal">extended_type_info implementation</code>.
</dd>

<dt><h4><code style="white-space: normal"><pre>
template&lt;class ETI&gt;
static extended_type_info *
ETI::find();
</pre></code></h4></dt>
<dd>
Return a pointer to the instance of
<code style="white-space: normal">extended_type_info</code>
which corresponds to type T.  Normally these instances are static objects so
this just amounts to returning the address of this static object.
</dd>

<dt><h4><code style="white-space: normal"><pre>
template&lt;class ETI&gt;
static void 
ETI::key_register(const char * key);
</pre></code></h4></dt>
<dd>
The main function is to invoke key_register to add the GUID to the
global table.  Depending on the type id system being used, it might
perform other initializaition functions as well.
</dd>
</dl>

It must define the following 
<a href="../../mpl/doc/refmanual/integral-constant.html">
Itegral Constant</a>
of type 
<a href="../../mpl/doc/refmanual/bool.html">bool</a>:
<dl>
<dt><h4><code style="white-space: normal"><pre>
ETI::is_polymorphic
</pre></code></h4></dt>
<dd>
</dd>

</dl>

<h3><a name="models">Models</a></h3>
The serialization library includes two distinct
<code style="white-space: normal"><a target="extended_type_info.hpp" href="../../../boost/serialization/extended_type_info.hpp">extended_type_info</a></code>
implementations.
<p>
<code style="white-space: normal"><h4><a target="extended_type_info_typeid.hpp" href = "../../../boost/serialization/extended_type_info_typeid.hpp">
extended_type_info_typeid</a></h4></code>is implemented in terms of the standard typeid(). It presumes that RTTI support is enabled
by the compiler.
<p>
<code style="white-space: normal"><h4><a target="extended_type_info_no_rtti.hpp" href="../../../boost/serialization/extended_type_info_no_rtti.hpp">
extended_type_info_no_rtti</a></h4></code>
is implemented in a way that doesn't rely on the existence RTTI. 
However, it does require that all classes for which type id is to be used implement
a virtual function of the signiture:
<code><pre>
virtual const char * get_key();
</pre></code>
which returns a unique string the most derived object this class.  
This function must be virtual in order to implement the functionality required by
<code style="white-space: normal">ETI::get_derived_extended_type_info</code>
as described above.  
<h3><a name="example">Example</a></h3>
The test program <code style="white-space: normal"><a target="test_no_rtti" href="../test/test_no_rtti.cpp">test_no_rtti</a></code>
implements this function in terms of the <code style="white-space: normal"><a target="extended_type_info_no_rtti.hpp" href="../../../boost/serialization/extended_type_info_no_rtti.hpp">
extended_type_info</a></code> API above to return the export key associated with the class.  
This requires that non-abstract types be exported.

<hr>
<p><i>&copy; Copyright <a href="http://www.rrsd.com">Robert Ramey</a> 2005. 
Distributed under the Boost Software License, Version 1.0. (See
accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
</i></p>
</body>
</html>
